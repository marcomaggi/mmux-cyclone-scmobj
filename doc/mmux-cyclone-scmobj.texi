\input texinfo.tex
@c %**start of header
@setfilename mmux-cyclone-scmobj.info
@settitle @sc{mmux} Cyclone ScmObj
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      ScmObj for Cyclone

@c To be used as @value{PACKAGE} whenever we need to include the full name of this package.
@set PACKAGE                    @sc{mmux} Cyclone Scmobj

@c To be used as @value{PACKAGE} whenever we need to include the nickname of the project: the name
@c that is used to compose the distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cyclone-scmobj

@c To be used as @value{AUTHOR} whenever we need to include the list of authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the email of the *single* author
@c of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the list of copyright years.
@set COPYRIGHT_YEARS            2020

@set CYCLONE_VERSION                    0.17
@set MMUX_CYCLONE_CHECKS_VERSION        0.1.0

@c ------------------------------------------------------------

@set PackageStem                scmobj

@set PackageAutoconfPrefix      MMUX_CYCLONE_SCMOBJ
@set PackagePkgconfigModule     mmux-cyclone-scmobj

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmux{}
@sc{mmux}
@end macro

@macro scmobj{}
ScmObj
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a Cyclone language library
implementing an object--oriented programming framework.  Cyclone is a Scheme-to-C compiler
supporting the language features as defined in the ``Revised^7 Report on Scheme''.

The package supports @posix{} platforms.  This package should work with Cyclone version
@value{CYCLONE_VERSION}.  To run the test suite this package depends upon the external package:
@mmux{} Cyclone Checks, at least version @value{MMUX_CYCLONE_CHECKS_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*
Copyright @copyright{} 1996 Dorai Sitaram

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cyclone-scmobj: (mmux-cyclone-scmobj).   An object--oriented programming framework for Cyclone.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* intro::                       Introduction to the library.
* example::                     Objects layout examples.
* class::                       Classes.
* instance::                    Instances.
* inspect::                     Inspecting classes and instances.
* slot::                        Accessing slots.
* generic::                     Generic functions and methods.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmux.cyclone.scmobj}, library
@cindex Library @library{mmux.cyclone.scmobj}


This document describes version @value{VERSION} of @value{PACKAGE}, a Cyclone language library
implementing an object--oriented programming framework.  Cyclone is a Scheme-to-C compiler
supporting the language features as defined in the ``Revised^7 Report on Scheme''.

This package supports @posix{} platforms.  This package should work with Cyclone version
@value{CYCLONE_VERSION}.  To run the test suite this package depends upon the external package:
@mmux{} Cyclone Checks, at least version @value{MMUX_CYCLONE_CHECKS_VERSION}.

The package installs the library @library{mmux.cyclone.scmobj} along with its import libraries; to
require the library and import its syntactic bindings in a module we can do:

@example
(import (mmux.cyclone.scmobj))
@end example

The library @library{mmux.cyclone.scmobj} defines an object system for Scheme that provides: simple
and multiple inheritance, generic functions, multimethods.  It resembles @clos{} (the Common Lisp
Object System), but it does not implement a meta object protocol (@acronym{MOP}).

The library is a reorganisation and repackaging of ScmObj, an object system for Scheme implemented
by Dorai Sitaram.

This library has the main purpose of keeping the source code simple and understandable, so that it
can be taken as starting point for more sophisticated object systems.

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmux-scmobj-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmux-scmobj-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmux-scmobj-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmux-scmobj-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmux-scmobj-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmux-scmobj-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmux-scmobj-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node intro
@chapter Introduction to the library


@scmobj{} objects, that is classes and instances, are association lists: Proper lists of pairs whose
cars are symbols and whose cdrs can be any value.

In this document: each pair is called @dfn{slot}; the symbol is called @dfn{slot name}; the value is
called @dfn{slot value}.  By convention the slot name symbols must have name starting with a colon
@code{:}.

A @dfn{class} object is an alist whose first slot's name is @code{:class}, and the other slot names
are:

@example
:class-definition-name
:class-precedence-list
:slots
@end example

An instance object is an alist whose first slot's name is @code{:class}, and the other slot names
are configured by the user.


@deffn Slot :class
It must be the first slot for both class and instance objects.

For an instance object: The value must be the class of the instance.

For a class object: The value must be the predefined @class{class} object.  So a class object is a
special case of instance object.
@end deffn


@deffn Slot :class-definition-name
A class object's slot whose value is the ``public name'' of the class.  By convention it must be a
symbol whose name is enclosed in angular parentheses.  It is useful to print debug messages.
@end deffn


@deffn Slot :class-precedence-list
A class object's slot whose value is a list representing the hierarchy of superclasses for the
instance objects of the class, or @false{} if the class has no precedence list.  It is used for
dispatching of multimethods.

Notice that the value of this slot does @strong{not} hold the class object itself.
@end deffn


@deffn Slot :slots
A class object's slot whose value is the list of slot names for the instances of the class, or
@false{} if instances have no slots.  For the predefined @class{class} object, the list is:

@example
(:class-definition-name :class-precedence-list :slots)
@end example

Notice that the symbol @code{:class} is @strong{not} included.
@end deffn

@c page
@node example
@chapter Objects layout examples


In the following it is not always convenient to show the full layout; to
highlight informations of interest, it is better to omit the layout of
class objects nested into class objects.  When this is done the string
@code{#<apple>} is included in place of the layout of the class
@class{apple}.

Let's start with the layout of @class{class} itself:

@example
((:class . #<class>)
 (:class-definition-name . <class>)
 (:class-precedence-list . #f)
 (:slots . (:class-definition-name
            :class-precedence-list
            :slots)))
@end example

@noindent
we see that the class of @class{class} is @class{class} itself.

As an example of class hierarchy, let's define a class with no
superclass and no slots:

@example
(define-class <biologic>)
@end example

@noindent
its layout is this:

@example
((:class . #<class>)
 (:class-definition-name . <biologic>)
 (:class-precedence-list . #f)
 (:slots . #f))
@end example

@noindent
now we derive a class from it, still without slots:

@example
(define-class <fruit> (<biologic>))
@end example

@noindent
@class{fruit} is a @dfn{subclass} of @class{biologic}, @class{biologic}
is a @dfn{superclass} of @class{fruit}; the layout of the subclass is:

@example
((:class . #<class>)
 (:class-definition-name . <fruit>)
 (:class-precedence-list . (#<biologic>))
 (:slots . #f))
@end example

@noindent
finally we subclass again adding slots:

@example
(define-class <apple> (<fruit>)
  :variety :colour :quality)
@end example

@noindent
and the layout is:

@example
((:class . #<class>)
 (:class-definition-name . <apple>)
 (:class-precedence-list . (#<fruit> #<biologic>))
 (:slots . (:variety :colour :quality)))
@end example

We have a usable class, so we instantiate it:

@example
(define o (make <apple>
            :variety 'renetta
            :colour  'green
            :quality 'high))
@end example

@noindent
and the layout of the instance is:

@example
((:class   . #<apple>)
 (:variety . renetta)
 (:colour  . green)
 (:quality . high))
@end example

We may want to add a price:

@example
(define-class <price> () :tag)

(define-class <priced-apple> (<apple> <price>))
@end example

@noindent
and the layout of the class with multiple inheritance is:

@example
((:class . #<class>)
 (:class-definition-name . <priced-apple>)
 (:class-precedence-list . (#<apple>
                            #<fruit>
                            #<biologic>
                            #<price>))
 (:slots . (:variety :colour :quality :tag)))
@end example

The instance of a priced apple:

@example
(define p (make <priced-apple>
            :variety 'renetta
            :colour  'green
            :quality 'high
            :tag 100))
@end example

@noindent
has layout:

@example
((:class   . #<priced-apple>)
 (:variety . renetta)
 (:colour  . green)
 (:quality . high)
 (:tag     . 100))
@end example

@c page
@node class
@chapter Classes


@menu
* class make::                  Making classes
* class chart::                 A chart for predefined classes
* class core::                  Core class types.
* class list::                  List types.
* class compound::              Non-list compound data types.
* class numeric::               Numeric data types.
* class port::                  Port types.
* class misc::                  Miscellaneous types.
@end menu

@c page
@node class make
@section Making classes


@deffn Syntax make-class @var{list-of-superclasses} . @var{class-slots}
Build and return a new class value.

@var{list-of-superclasses} is the list of superclasses of the new
class; acceptable values are:

@itemize
@item
The empty list, in which case @class{class} is added by default.

@item
A list containing only the @class{class} value.

@item
A list of previously defined base classes.
@end itemize

@var{class-slots} must be a list of symbols representing the slot names.
By convention their names should start with a colon character, @code{:}.
It is possible for a class to add no new slots, that is
@var{class-slots} can be the empty string: This allows subclassing for
the only purpose of method dispatching.

Notice that classes instantiated with @func{make-class} will have no
class definition name.  The @func{class-definition-name} function
applied to them will return the symbol @code{:uninitialised}.
@end deffn


@deffn Syntax define-class @var{name} @var{list-of-superclasses} . @var{class-slots}
A wrapper for @func{make-class} that defines a new variable named
@var{name} and assigns the new class to it.  The class definition name
of the class is initialised to @var{name}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples

Definition of a class with no superclasses and 3 slots named: @code{:a},
@code{:b} and @code{:c}:

@example
(define <one>
  (make-class () :a :b :c)
@end example

@noindent
the same with explicit selection of the base @class{class}:

@example
(define <one>
  (make-class (<class>) :a :b :c)
@end example

Simple inheritance:

@example
(let* ((<one>   (make-class ()      :a :b :c))
       (<two>   (make-class (<one>) :d :e :f))
       (<three> (make-class (<two>) :g :h :i)))
  ---)
@end example

@noindent
and multiple inheritance:

@example
(let* ((<one>   (make-class ()            :a :b :c))
       (<two>   (make-class (<one>)       :d :e :f))
       (<three> (make-class (<two> <one>) :g :h :i)))
  ---)
@end example

Defining classes using @func{define-class}:

@example
(define-class <one> ()
  :a :b :c)

(define-class <two> (<one>)
  :d :e :f)

(define-class <three> (<two>)
  :g :h :i)
@end example

@c page
@node class chart
@section A chart for predefined classes


@example
<class>
   |
   |                             -> <input-port>
   |                            |
   |                            +-> <output-port>
   |                            |
   |                            +-> <binary-port>
   |                            |
   |               --> <port> --+-> <textual-port>
   |              |
   |              +--> <record>
   |              |
   |              +--> <string>
   |              |
   |              +--> <char>
   v              |
<builtin-class> --+-------+-------+
   |              |       |       |
   v              v       v       v
<number>        <pair> <vector> <bytevector>
   |              |
   v              |
<complex>         +--------------+------------
   |              |              |            |
   v              v              v            v
<real>          <list>    <dotted-list> <circular-list>
   |
   v
<rational>
   |
   v
<exact-integer>
@end example

@c page
@node class core
@section Core class types


@deftp {Class} <class>
The base class of all the @library{scmobj} classes.
@end deftp


@deftp {Class} <builtin-class>
The base class builtin Scheme values.
@end deftp

@c page
@node class list
@section List types


@deftp Class @aclass{pair}
Class for values that satisfy @func{pair?}.
@end deftp


@deftp Class @aclass{list}
Class for values that satisfy @func{list?}.
@end deftp


@deftp Class @aclass{circular-list}
Class for values that satisfy @func{circular-list?}.  Notice that a pair
and a proper list are not circular lists.
@end deftp


@deftp Class @aclass{dotted-list}
Class for values that satisfy @func{dotted-list?}.  Notice that a pair
is always a dotted list, but a proper list is not a dotted list.
@end deftp

@c page
@node class compound
@section Non--list compound data types


@deftp Class @aclass{vector}
Class for values that satisfy @func{vector?}.
@end deftp


@deftp Class @aclass{bytevector}
Class for values that satisfy @func{bytevector?}.
@end deftp


@deftp Class @aclass{record}
Class for values that satisfy @func{record?}.
@end deftp

@c page
@node class numeric
@section Numeric data types


@deftp Class @aclass{number}
Class for values that satisfy @func{number?}.
@end deftp


@deftp Class @aclass{complex}
Class for values that satisfy @func{complex?}.
@end deftp


@deftp Class @aclass{real}
Class for values that satisfy @func{real?}.
@end deftp


@deftp Class @aclass{rational}
Class for values that satisfy @func{rational?}.
@end deftp


@deftp Class @aclass{exact-integer}
Class for values that satisfy @func{exact-integer?}.
@end deftp

@c page
@node class port
@section Port types


The following classes for input/output ports are predefined.


@deftp Class @aclass{port}
Class for values that satisfy @func{port?}.
@end deftp


@deftp Class @aclass{input-port}
Class for values that satisfy @func{input-port?}.
@end deftp


@deftp Class @aclass{output-port}
Class for values that satisfy @func{output-port?}.
@end deftp


@deftp Class @aclass{textual-port}
Class for values that satisfy @func{textual-port?}.
@end deftp


@deftp Class @aclass{binary-port}
Class for values that satisfy @func{binary-port?}.
@end deftp


The binary/textual attributes are not mututally exclusive with the
input/output attributes, so if we need it, we can use multiple
inheritance:

@example
(define-class <binary-input-port> (<binary-port> <input-port>))
@end example

@c page
@node class misc
@section Miscellaneous types


@deftp {Class} <string>
Class for values that satisfy @func{string?}.
@end deftp


@deftp {Class} <char>
Class for values that satisfy @func{char?}.
@end deftp

@c page
@node instance
@chapter Instances


@deffn Macro make @var{class-object} . @var{init-slots}
Build and return a new instance object of class @var{class-object}.  The
optional arguments are symbol/value couples used to initialise the
slots: The symbol must be the name of a slot, the value its value.

It is @strong{not} mandatory to initialise all the slots in a class
instance.  Uninitialised slots will be initialised to the symbol
@code{:uninitialised}.
@end deffn


@subsubheading Examples

Instantiate a class with 3 slots:

@example
(let* ((<one> (make-class () :a :b :c))
       (o     (make <one>
                 :a 1 :b 2 :c 3)))
  ---)
@end example

Instantiate a class with superclasses, initialising all the slots:

@example
(let* ((<one>   (make-class () :a :b :c))
       (<two>   (make-class (<one>) :d :e :f))
       (<three> (make-class (<two>) :g :h :i))
       (o       (make <three>
                   :a 1 :b 2 :c 3
                   :d 4 :e 5 :f 6
                   :g 7 :h 8 :i 9)))
  ---)
@end example

@c page
@node inspect
@chapter Inspecting classes and instances


@defun class? @var{obj}
Does its best to determine if @var{obj} is a valid class object.
@end defun


@defun instance? @var{obj}
Does its best to determine if @var{obj} is a valid instance object.
@end defun


@defun class-of @var{class/instance}
Return the class of the argument.  This function can be applied to both
class objects and instance objects.  If this function is not able to
determine a class, it returns @false{}; this should never happen,
though.
@end defun


@defun is-a? @var{class/instance} @var{class}
Return true if @var{class/instance} is an object of class @var{class}.
This function can be applied to both class objects and instance objects.
@end defun


@defun subclass? @var{class-1} @var{class-2}
Return true if @var{class-1} is a subclass of @var{class-2}, false
otherwise.
@end defun


@defun class-definition-name @var{class}
Return the class definition name for @var{class}.  Note that the
definition name is set only for classes instantiated with
@func{define-class}, for classes instantiated with @func{make-class} the
return value is the symbol @code{:uninitialised}.
@end defun


@defun class-precedence-list @var{class}
Return a list of classes representing the class precendence list, used
for method dispatching.  Note that @var{class} itself is @strong{not}
part of the class precedence list.
@end defun


@defun class-slots @var{class}
Return a list of symbols representing the slot names of @var{class}.
The symbol @code{:class} is excluded.
@end defun


@defun class-direct-slots @var{class}
Return a list of symbols representing the slot names of @var{class},
excluding the slots of its superclasses.
@end defun

@c page
@node slot
@chapter Accessing slots


@defun slot-ref @var{object} @var{slot-name}
Return the value of @var{slot-name} in @var{object}.  @var{slot-name}
must be a symbol.  It is an error if @var{object} has no slot named
@var{slot-name}.
@end defun


@defun {slot-set!} @var{object} @var{slot-name} @var{new-value}
Overwrite the value of @var{slot-name} in @var{object} with
@var{new-value}.  @var{slot-name} must be a symbol.  It is an error if
@var{object} has no slot named @var{slot-name}.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

Basic slot access:

@example
(let* ((<one>  (make-class () :a :b :c))
       (o      (make <one>
                 :a 1 :b 2 :c 3)))

  (slot-set! o ':b 123)

  (list (slot-ref o ':b)
        (slot-ref o ':a)
        (slot-ref o ':c))) @result{} '(123 1 3)
@end example

It is possible to define simple accessors for slots like this:

@example
(define-class <one> ()
  :alpha :beta)

(define alpha
  (case-lambda
    ((o)
     (slot-ref  o ':alpha))
    ((o v)
     (slot-set! o ':alpha v))))

(define o (make <one> :alpha 123))

(alpha o)       @result{} 123
(alpha o 456)
(alpha o)       @result{} 456
@end example

@noindent
or better:

@example
(define-class <one> ()
  :alpha :beta)

(define (make-accessor slot-name)
  (case-lambda
    ((o)
     (slot-ref  o slot-name))
    ((o v)
     (slot-set! o slot-name v))))

(define o (make <one> :alpha 123))
(define alpha
  (make-accessor ':alpha))

(alpha o)       @result{} 123
(alpha o 456)
(alpha o)       @result{} 456
@end example

@noindent
and closure accessors are also possible:

@example
(define-class <one> ()
  :alpha :beta)

(define (make-accessor o slot-name)
  (case-lambda
    (()
     (slot-ref  o slot-name))
    ((v)
     (slot-set! o slot-name v))))

(define o (make <one> :alpha 123))
(define alpha
  (make-accessor o ':alpha))

(alpha)         @result{} 123
(alpha 456)
(alpha)         @result{} 456
@end example

@c page
@node generic
@chapter Generic functions and methods


@dfn{Generic functions} are procedures that can be specialized to the
classes of their arguments.  Each specialisation of a generic function
is called @dfn{method}.  When applying a generic function to a set of
arguments, the most specific method with respect to the arguments'
classes is chosen.

@menu
* generic application::         How generic functions and methods
                                are invoked.
* generic dispatching::         How methods are dispatched.
* generic define::              Defining generic functions and methods.
* generic next::                Invoking the next method.
* generic examples::            Examples of method dispatching.
@end menu

@c page
@node generic application
@section How generic functions and methods are invoked


@library{scmobj} allows the definition of four kinds of methods:
@code{:primary}, @code{:around}, @code{:before} and @code{:after}.  The
short description is that @code{:around} methods are applied first, then
@code{:before}, @code{:primary} and @code{:after} methods are applied in
this order.

When a generic function is applied to a tuple of arguments, the
following happens:

@enumerate
@item
For each argument in the tuple a class is determined.  The tuple of
classes is called @dfn{signature}.
@end enumerate

For each kind of method, the generic function maintains an internal
collection in which every method's closure is associated to a signature.

@enumerate 2
@item
For each kind of method: The internal collection is queried for all the
methods applicable to the tuple of arguments, using the signature as
search key.

@item
For each kind of method: The list of applicable methods is sorted from
the more specific to the least specific for the signature.  The list of
@code{:after} methods is reversed.
@end enumerate

From now on the lists of sorted, applicable methods are handled as
stacks; the stacks of @code{:primary}, @code{:around} and @code{:before}
methods have most specific method on the top; the stack of @code{:after}
methods has the least specific method on the top.

From now on the application of the generic function enters an implicit
loop in which more methods' closures can be applied to the same tuple of
arguments.  The loop can terminate if a method's closure throws an
exception or, for @code{:around} and @code{:primary} methods, if it does
not take the special action of calling @func{call-next-method}.

The loop is a bit articulated, so we may have to read the following
descriptions multiple times.  We split the description in two branches:
First a simplified invocation for generic functions having at least one
applicable @code{:primary} method, no @code{:around} methods, and
performing no calls to @func{call-next-method}; then the full
application algorithm.

Here is the simplified branch with no @code{:around} methods and no
calls to @func{call-next-method}:

@enumerate 4
@item
Pop all the @code{:before} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.  The return value of this application is
saved in a temporary location.

@item
Pop all the @code{:after} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Return the saved return value of the @code{:primary} method.
@end enumerate

Here is the full application algorithm:

@enumerate 4
@item
Test if this function application originated from a call to
@func{call-next-method} from a @code{:before} or @code{:after} method.
If it has: Raise an assertion violation.

@item
Test if this function application originated from a call to
@func{call-next-method} from a @code{:primary} method.  If it has:

@enumerate a
@item
If the stack of @code{:primary} methods is empty raise an assertion
violation.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.

@item
Break out returning the return value of this application: It becomes the
return value of @func{call-next-method}.
@end enumerate

@item
If the stack of @code{:primary} methods is empty: Raise an assertion
violation.  This condition means that the generic function has no
applicable methods for the tuple of arguments.

@item
If the stack of @code{:around} methods is not empty: Pop the next
@code{:around} method and apply its closure to the tuple of arguments.
Break out returning the return value of this application.

@item
Pop all the @code{:before} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.  The return value of this application is
saved in a temporary location.

@item
Pop all the @code{:after} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Return the saved return value of the @code{:primary} method.
@end enumerate

The @code{:primary} methods are meant to do the real work of the
function.  Only the most specific is applied to the arguments, however
it can use @func{call-next-method} to invoke a least specialised version
and use its return value.

@code{:before} and @code{:after} methods are meant to execute additional
work before and after the primary methods.  While @code{:before} methods
are applied from the most specific to the least specific, @code{:after}
methods are applied from the least specific to the most specific.
Notice that the @code{:after} methods have no access to the return value
of the @code{:primary} methods.

@code{:around} methods are yet another level for performing tasks before
and after the primary methods; only the most specific is applied to the
arguments.  It is expected, but not mandatory, that an @code{:around}
method invokes @func{call-next-method}; such invocations will consume
all the applicable @code{:around} methods, from the least to the most
specific, and then will start the application of @code{:before},
@code{:primary} and @code{:after} methods.

@c page
@node generic dispatching
@section How methods are dispatched


Here we attempt the formulation of the rules by which methods are
dispatched.  A method is identified by a triplet of values: a list of
classes, called signature, representing the classes or expected
arguments; a boolean value telling if the closure accepts rest
arguments; the closure.

@c ------------------------------------------------------------

@subsubheading Applicability

First we need to understand when a method is applicable to a tuple of
arguments.  Given a tuple of arguments, a method supporting no rest
arguments is applicable to it if:

@enumerate
@item
The length of the signature is equal to the length of the arguments'
tuple.

@item
Position by position, the class in the signature is @func{eq?} to the
class of the value in the tuple, or it is in the class precedence list
of the class of the value in the tuple.
@end enumerate

@noindent
a method supporting rest arguments is applicable to it if:

@enumerate
@item
The length of the signature is less than or equal to the length of the
arguments' tuple.

@item
Position by position, up to the last element in the signature, the class
in the signature is @func{eq?} to the class of the value in the tuple,
or it is in the class precedence list of the class of the value in the
tuple.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Specificity

Now we can understand how to determine which one, among two applicable
methods, is more specific for a tuple of arguments.  Let's call the
methods @var{A} and @var{B}.  Notice that it is impossible for two
distinct methods, in the same generic function, to have the same
signature and the same support for rest arguments.

@enumerate
@item
If both @var{A} and @var{B} support rest arguments: The one with the
longest signature is more specific.

@item
The classes in the signatures are compared in couples, position by
position from the beginning to the end.

@enumerate a
@item
If the classes are @func{eq?}, the next couple is inspected.

@item
If the class from @var{A} is a subclass of the one from @var{B}: Then
@var{A} is more specific than @var{B}.  If no subclass relation exists
between the two, the next couple is inspected.

@item
For the current position, the class of the value in the tuple of
arguments is determined, its class precedence acquired.  The positions
of the classes from the signatures in the class precedence list is
computed: If the class from @var{A} comes first, then @var{A} is more
specific than @var{B}.
@end enumerate

@item
If the methods' signatures have the same length, and, position by
position, the classes of @var{A} are @func{eq?} to the classes of
@var{B}, but @var{A} supports rest arguments while @var{B} does not:
Then @var{B} is more specific than @var{A}.
@end enumerate

@c page
@node generic define
@section Defining generic functions and methods


The number of arguments (arity) of a generic function is undefined:
Every method can have a different number of arguments.


@deffn Macro define-generic @var{name}
Define a new generic function and bind it to @var{name}.
@end deffn


@defun make-generic-function
Build and return a new generic function.
@end defun


@deffn Macro declare-method @var{generic} (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method (@var{generic} @var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :primary (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :before (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :after (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :around (@var{arg-spec} ...) . @var{body}
Add a new method to an already existent generic function, @var{generic}.
A declaration is @strong{not} a definition.

The qualifier specifies the kind of method; when the qualifier is not
present, it defaults to @code{:primary}.

The list of @var{arg-spec} specifies the classes of the values for which
the method specialises the function.  Notice that rest arguments are
supported and specified with the usual syntax.  A @var{arg-spec} can be:

@table @code
@item (@var{arg} @var{class})
Where @var{arg} is the formal name of the argument and @var{class} the
class of expected values.

@item @var{arg}
Where @var{arg} is the formal name of the argument.  In this case the
class defaults to @true{}, which is interpreted as superclass of every
other class.
@end table

If a method is defined with the same signature, and support for rest
arguments, of an already registered method: The old method is
overwritten by the new one.  Two methods having, position by position,
arguments of the same class, but such that one supports rest arguments
and the other does not, are different.
@end deffn


@deffn Macro add-method @var{generic} @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :primary @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :before @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :after @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :around @var{signature} @var{has-rest} @var{closure}
Add a new method to an already existent generic function, @var{generic}.
@var{signature} must be a list of classes for which the method
specialises the function.  @var{closure} must be the method's closure.
When the method qualifier is not present, it defaults to
@code{:primary}.  @var{has-rest} must be @true{} or @false{}, when
@true{} it means that the closure supports rest arguments.
@end deffn

@c page
@node generic next
@section Invoking the next method


@defun call-next-method
To be invoked from a @code{:primary} or @code{:around} method.  Call the
next most specific method.
@end defun


@defun next-method?
Return true if a next method is available.  Available next methods are
@code{:primary} and @code{:around} methods.  After the first
@code{:primary} method has been called, only @code{:primary} methods are
considered.

It can be invoked by any kind of method.
@end defun

@c page
@node generic examples
@section Examples of method dispatching.


Here we show with some examples what we have to expect from the
multimethod dispatching of @library{scmobj}.  In the following examples
the string @code{%apple} is written in place of the value bound to the
symbol @class{apple}.


@subsubheading Simple inheritance

Let's examine this example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<one>))
(define-class <c>   (<two>))
@end example

@noindent
the class hierarchy is:

@example
<top> -> <one> -> <two> -> <c>
@end example

@noindent
and the full class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: the method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

@c ------------------------------------------------------------

@subsubheading Multiple inheritance


Let's examine this example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<top>))
(define-class <c> (<two> <one>))
@end example

@noindent
the class hierarchy is:

@example
<top> -+-> <one> -+-> <c>
       |          |
        -> <two> -
@end example

@noindent
and given the order in which the classes where handed to
@func{define-class}, the class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: The method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

Another multiple inheritance example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<top>))
(define-class <three> (<two>))
(define-class <c> (<three> <one>))
@end example

@noindent
the class hierarchy is:

@example
<top> -+-------> <one> ------+-> <c>
       |                     |
        -> <two> -> <three> -
@end example

@noindent
and given the order in which the classes where handed to
@func{define-class}, the class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %three %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: The method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

@c ------------------------------------------------------------

@subsubheading Other examples

Let's look at this:

@example
(define-class <top> ())
(define-class <c>   (<top>))
(define-class <one> (<c>))

(define-generic doit)
(declare-method doit ((o <one>)) 'one)

(doit (make <c>))
@end example

@noindent
this will result in a ``no method defined for these argument classes'
error because a value of class @class{c} is @strong{not} a value of
class @class{one}.  For a method to be applicable: the class from the
signature of the method has to be in in the class list of the argument,
not vice versa.  That is:

@example
(subclass? <c> <one>)
@end example

@noindent
must evaluate to true.

@c ------------------------------------------------------------

@subsubheading Kinds of methods

In the examples for the application of different kinds of methods, we
will make use of the following hierarchy of classes:

@example
(define-class <a> () :a)
(define-class <b> () :b)
(define-class <c> () :c)
(define-class <d> () :d)
(define-class <e> () :e)

(define-class <pp> (<a> <b>))
(define-class <qq> (<c> <d>))
(define-class <rr> (<pp> <e> <qq>))

(define pp (make <pp> :a 1 :b 2))
(define qq (make <qq> :c 3 :d 4))
(define rr (make <rr> :a 10 :b 20 :c 30 :d 40))
@end example

First some error case.  The following will raise an error because
@code{:before} methods are forbidden to @func{call-next-method}:

@example
(define-generic alpha)

(declare-method alpha ((o <a>))
  1)

(declare-method alpha :before ((o <a>))
  (call-next-method))

(alpha pp)
@end example

The following will raise an error because we @func{call-next-method}
when no next method is available:

@example
(define-generic alpha)

(declare-method alpha ((o <a>))
  (call-next-method))

(alpha pp)
@end example

The following will raise an error because we apply a generic function
when no @code{:primary} method has been defined:

@example
(define-generic alpha)

(declare-method alpha :around ((o <a>))
  (call-next-method))

(alpha pp)
@end example

Here is a full example showing the order of applications for all the
kinds of methods; it makes use of the @func{with-result} and
@func{add-result} forms from the @library{checks} library:

@example
(define-generic alpha)

(declare-method alpha :before ((o <rr>)) (add-result 1))
(declare-method alpha :before ((o <pp>)) (add-result 2))
(declare-method alpha :before ((o <a>))  (add-result 3))
(declare-method alpha :before ((o <b>))  (add-result 4))
(declare-method alpha :before ((o <e>))  (add-result 5))

(declare-method alpha :after  ((o <rr>)) (add-result 10))
(declare-method alpha :after  ((o <pp>)) (add-result 9))
(declare-method alpha :after  ((o <a>))  (add-result 8))
(declare-method alpha :after  ((o <b>))  (add-result 7))
(declare-method alpha :after  ((o <e>))  (add-result 6))

(declare-method alpha :around  ((o <rr>)) (cons 1 (call-next-method)))
(declare-method alpha :around  ((o <pp>)) (cons 2 (call-next-method)))
(declare-method alpha :around  ((o <a>))  (cons 3 (call-next-method)))
(declare-method alpha :around  ((o <b>))  (cons 4 (call-next-method)))
(declare-method alpha :around  ((o <e>))  (cons 5 (call-next-method)))

(declare-method alpha :primary ((o <rr>)) (cons 6 (call-next-method)))
(declare-method alpha :primary ((o <pp>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <a>))  (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <b>))  (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <e>))  10)

(with-result (alpha rr))
@result{} ((1 2 3 4 5 6 7 8 9 . 10)
    (1 2 3 4 5 6 7 8 9 10))
@end example

@noindent
notice, in particular, how multiple inheritance is handled: Methods for
the @class{b} and @class{e} classes, coming as seconds in the class
inheritance lists, are applied after the methods of the @class{a} and
@class{pp} classes.

Now let's consider a the following class hierarchy with diamond
inheritance:

@example
(define-class <t> ()    :t)   ;  <t>---+
(define-class <x> (<t>) :x)   ;        v
(define-class <y> (<x>) :y)   ;   --- <x> ---
(define-class <w> (<x>) :w)   ;  |           |
(define-class <z> (<y> <w>))  ;  v           v
                              ; <y>         <w>
                              ;  |           |
                              ;   --> <z> <--

(define z (make <z> :t 0 :x 1 :y 2 :w 3))
@end example

@noindent
and let's define and apply all the kinds of methods:

@example
(define-generic alpha)

(declare-method alpha :around ((o <z>))  (cons 1 (call-next-method)))
(declare-method alpha :around ((o <y>))  (cons 2 (call-next-method)))
(declare-method alpha :around ((o <w>))  (cons 3 (call-next-method)))
(declare-method alpha :around ((o <x>))  (cons 4 (call-next-method)))
(declare-method alpha :around ((o <t>))  (cons 5 (call-next-method)))

(declare-method alpha :primary ((o <z>)) (cons 6 (call-next-method)))
(declare-method alpha :primary ((o <y>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <w>)) (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <x>)) (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <t>)) 10)

(declare-method alpha :before ((o <z>))  (add-result 1))
(declare-method alpha :before ((o <y>))  (add-result 2))
(declare-method alpha :before ((o <w>))  (add-result 3))
(declare-method alpha :before ((o <x>))  (add-result 4))
(declare-method alpha :before ((o <t>))  (add-result 5))

(declare-method alpha :after ((o <z>))   (add-result 10))
(declare-method alpha :after ((o <y>))   (add-result 9))
(declare-method alpha :after ((o <w>))   (add-result 8))
(declare-method alpha :after ((o <x>))   (add-result 7))
(declare-method alpha :after ((o <t>))   (add-result 6))

(with-result (alpha z))
@result{} ((1 2 3 4 5 6 7 8 9 . 10)
    (1 2 3 4 5 6 7 8 9 10))
@end example

Here is yet another example with diamond inheritance:

@example
(define-class <0> () :0)        ;    <0>--+
(define-class <1> (<0>) :1)     ;         v
(define-class <2> (<1>) :2)     ;   ---- <1> ----
(define-class <3> (<1>) :3)     ;  |             |
(define-class <4> (<3>) :4)     ;  v             |
(define-class <5> (<4> <2>))    ; <3>            |
                                ;  |             |
                                ;  v             v
                                ; <4>           <2>
                                ;  |             |
                                ;   ---> <5> <---

(define n (make <5> :0 0 :1 1 :2 2 :3 3 :4 4))
@end example

@noindent
and let's define and apply all the kinds of methods:

@example
(define-generic alpha)

(declare-method alpha :around ((o <5>))  (cons 1 (call-next-method)))
(declare-method alpha :around ((o <4>))  (cons 2 (call-next-method)))
(declare-method alpha :around ((o <3>))  (cons 3 (call-next-method)))
(declare-method alpha :around ((o <2>))  (cons 4 (call-next-method)))
(declare-method alpha :around ((o <1>))  (cons 5 (call-next-method)))
(declare-method alpha :around ((o <0>))  (cons 6 (call-next-method)))

(declare-method alpha :primary ((o <5>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <4>)) (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <3>)) (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <2>)) (cons 10 (call-next-method)))
(declare-method alpha :primary ((o <1>)) (cons 11 (call-next-method)))
(declare-method alpha :primary ((o <0>)) 12)

(declare-method alpha :before ((o <5>))  (add-result 1))
(declare-method alpha :before ((o <4>))  (add-result 2))
(declare-method alpha :before ((o <3>))  (add-result 3))
(declare-method alpha :before ((o <2>))  (add-result 4))
(declare-method alpha :before ((o <1>))  (add-result 5))
(declare-method alpha :before ((o <0>))  (add-result 6))

(declare-method alpha :after ((o <5>))   (add-result 12))
(declare-method alpha :after ((o <4>))   (add-result 11))
(declare-method alpha :after ((o <3>))   (add-result 10))
(declare-method alpha :after ((o <2>))   (add-result 9))
(declare-method alpha :after ((o <1>))   (add-result 8))
(declare-method alpha :after ((o <0>))   (add-result 7))

(with-result (alpha n))
@result{} ((1 2 3 4 5 6 7 8 9 10 11 . 12)
    (1 2 3 4 5 6 7 8 9 10 11 12)))
@end example

We can conclude that, when it comes to method application:

@itemize
@item
If diamond inheritance is not present: The graph of inheritance is a
tree, which is flattened to a list representing the visit of a preorder
iterator.

@item
When diamond inheritance is present: Diamond groups are flattened to a
list with classes in the middle at the center:

@example
  -- <x> --
 |         |
 v         v
<y>       <w>       @result{}   (<z> <y> <w> <x>)
 |         |
  -> <z> <-

  ---- <1> ----
 |             |
 v             |
<3>            |
 |             |    @result{}  (<5> <4> <3> <2> <1>)
 v             v
<4>           <2>
 |             |
  ---> <5> <---
@end example

@noindent
then the graph is flattened and visited in preorder.
@end itemize

@c end of file
@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Cyclone can be downloaded from:

@center @url{https://github.com/justinethier/cyclone}

The original code is available at (last checked May 13, 2020):

@center @url{http://www.ccs.neu.edu/home/dorai/scmobj/scmobj.html}

The package @mmux{} Cyclone Checks is available from:

@center @url{https://github.com/marcomaggi/mmux-cyclone-checks/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
